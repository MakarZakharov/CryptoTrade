from django.shortcuts import render
from django.http import JsonResponse
from django.conf import settings
import pandas as pd
import os

def comparison_view(request):
    """Сторінка для завантаження власних файлів"""
    return render(request, 'charts/comparison.html')

def real_data_view(request):
    """Сторінка з реальними даними BTC"""
    return render(request, 'charts/real_data.html')

def load_parquet_data(request):
    """API endpoint для завантаження даних з Parquet файлів"""
    if request.method == 'POST' and request.FILES:
        try:
            file1 = request.FILES.get('file1')
            file2 = request.FILES.get('file2')

            # Читаємо перший файл
            if file1:
                df1 = pd.read_parquet(file1)
                numeric_cols1 = df1.select_dtypes(include=['number']).columns[:2]
                data1 = []
                for idx, row in df1.iterrows():
                    if len(numeric_cols1) >= 2:
                        data1.append({
                            'x': float(row[numeric_cols1[0]]),
                            'y': float(row[numeric_cols1[1]])
                        })
                    elif len(numeric_cols1) == 1:
                        data1.append({
                            'x': idx,
                            'y': float(row[numeric_cols1[0]])
                        })
            else:
                data1 = []

            # Читаємо другий файл
            if file2:
                df2 = pd.read_parquet(file2)
                numeric_cols2 = df2.select_dtypes(include=['number']).columns[:2]
                data2 = []
                for idx, row in df2.iterrows():
                    if len(numeric_cols2) >= 2:
                        data2.append({
                            'x': float(row[numeric_cols2[0]]),
                            'y': float(row[numeric_cols2[1]])
                        })
                    elif len(numeric_cols2) == 1:
                        data2.append({
                            'x': idx,
                            'y': float(row[numeric_cols2[0]])
                        })
            else:
                data2 = []

            return JsonResponse({
                'success': True,
                'data1': data1[:1000],
                'data2': data2[:1000],
                'columns1': list(df1.columns) if file1 else [],
                'columns2': list(df2.columns) if file2 else [],
            })

        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            }, status=400)

    return JsonResponse({'success': False, 'error': 'No files provided'}, status=400)

def load_btc_data(request):
    """Завантажити реальні дані BTC"""
    try:
        # Шлях до вашого Parquet файлу
        btc_file = os.path.join(
            settings.BASE_DIR, 
            'EnvironmentData', 'data', 'binance', 'BTCUSDC', 'parquet', 'd1',
            '2018_01_01-2025_10_25.parquet'
        )
        
        if not os.path.exists(btc_file):
            return JsonResponse({
                'success': False,
                'error': f'Файл не знайдено: {btc_file}'
            }, status=404)
        
        # Читаємо дані
        df = pd.read_parquet(btc_file)
        
        # Конвертуємо timestamp в числа для графіка
        if 'timestamp' in df.columns or 'date' in df.columns:
            time_col = 'timestamp' if 'timestamp' in df.columns else 'date'
            df[time_col] = pd.to_datetime(df[time_col])
            # Перетворюємо в Unix timestamp (секунди)
            time_values = (df[time_col] - pd.Timestamp("1970-01-01")) // pd.Timedelta('1s')
        else:
            time_values = df.index
        
        # Графік 1: Close Price (ціна закриття)
        data1 = []
        if 'close' in df.columns:
            for i in range(len(df)):
                data1.append({
                    'x': float(time_values.iloc[i]) if hasattr(time_values, 'iloc') else float(time_values[i]),
                    'y': float(df['close'].iloc[i]),
                    'date': str(df.index[i]) if isinstance(df.index[i], pd.Timestamp) else str(i)
                })
        
        # Графік 2: Volume (об'єм торгів)
        data2 = []
        if 'volume' in df.columns:
            for i in range(len(df)):
                data2.append({
                    'x': float(time_values.iloc[i]) if hasattr(time_values, 'iloc') else float(time_values[i]),
                    'y': float(df['volume'].iloc[i]),
                    'date': str(df.index[i]) if isinstance(df.index[i], pd.Timestamp) else str(i)
                })
        
        return JsonResponse({
            'success': True,
            'data1': data1[:2000],  # Обмежуємо до 2000 точок
            'data2': data2[:2000],
            'columns': list(df.columns),
            'shape': list(df.shape),
            'data1_label': 'BTC Close Price (USDC)',
            'data2_label': 'Trading Volume',
            'info': {
                'start_date': str(df.index[0]) if len(df) > 0 else None,
                'end_date': str(df.index[-1]) if len(df) > 0 else None,
                'total_days': len(df)
            }
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

def load_btc_custom_columns(request):
    """Завантажити BTC дані з вибраними колонками"""
    if request.method == 'POST':
        try:
            col1 = request.POST.get('column1', 'close')
            col2 = request.POST.get('column2', 'volume')
            
            btc_file = os.path.join(
                settings.BASE_DIR, 
                'EnvironmentData', 'data', 'binance', 'BTCUSDC', 'parquet', 'd1',
                '2018_01_01-2025_10_25.parquet'
            )
            
            df = pd.read_parquet(btc_file)
            
            # Конвертуємо timestamp
            if 'timestamp' in df.columns or 'date' in df.columns:
                time_col = 'timestamp' if 'timestamp' in df.columns else 'date'
                df[time_col] = pd.to_datetime(df[time_col])
                time_values = (df[time_col] - pd.Timestamp("1970-01-01")) // pd.Timedelta('1s')
            else:
                time_values = df.index
            
            data1 = []
            data2 = []
            
            if col1 in df.columns:
                for i in range(len(df)):
                    data1.append({
                        'x': float(time_values.iloc[i]) if hasattr(time_values, 'iloc') else float(time_values[i]),
                        'y': float(df[col1].iloc[i]),
                        'date': str(df.index[i]) if isinstance(df.index[i], pd.Timestamp) else str(i)
                    })
            
            if col2 in df.columns:
                for i in range(len(df)):
                    data2.append({
                        'x': float(time_values.iloc[i]) if hasattr(time_values, 'iloc') else float(time_values[i]),
                        'y': float(df[col2].iloc[i]),
                        'date': str(df.index[i]) if isinstance(df.index[i], pd.Timestamp) else str(i)
                    })
            
            return JsonResponse({
                'success': True,
                'data1': data1[:2000],
                'data2': data2[:2000],
                'data1_label': f'BTC {col1.upper()}',
                'data2_label': f'BTC {col2.upper()}'
            })
            
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            }, status=500)
    
    return JsonResponse({'success': False, 'error': 'Invalid request'}, status=400)

def get_parquet_columns(request):
    """Отримати список колонок з Parquet файлу"""
    if request.method == 'POST' and request.FILES.get('file'):
        try:
            file = request.FILES['file']
            df = pd.read_parquet(file)

            return JsonResponse({
                'success': True,
                'columns': list(df.columns),
                'numeric_columns': list(df.select_dtypes(include=['number']).columns),
                'shape': df.shape,
                'sample': df.head(5).to_dict('records')
            })
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            }, status=400)

    return JsonResponse({'success': False, 'error': 'No file provided'}, status=400)

def get_btc_columns(request):
    """Отримати список колонок з BTC файлу"""
    try:
        btc_file = os.path.join(
            settings.BASE_DIR, 
            'EnvironmentData', 'data', 'binance', 'BTCUSDC', 'parquet', 'd1',
            '2018_01_01-2025_10_25.parquet'
        )
        
        df = pd.read_parquet(btc_file)
        
        return JsonResponse({
            'success': True,
            'columns': list(df.columns),
            'numeric_columns': list(df.select_dtypes(include=['number']).columns)
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)